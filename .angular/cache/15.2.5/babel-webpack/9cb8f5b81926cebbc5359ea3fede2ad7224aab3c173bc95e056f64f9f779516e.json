{"ast":null,"code":"import _asyncToGenerator from \"C:/angular/front-app-angular-arielle/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BehaviorSubject } from 'rxjs';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Subject used to dispatch and listen for changes to the auto change detection status . */\nconst autoChangeDetectionSubject = new BehaviorSubject({\n  isDisabled: false\n});\n/** The current subscription to `autoChangeDetectionSubject`. */\nlet autoChangeDetectionSubscription;\n/**\n * The default handler for auto change detection status changes. This handler will be used if the\n * specific environment does not install its own.\n * @param status The new auto change detection status.\n */\nfunction defaultAutoChangeDetectionHandler(status) {\n  status.onDetectChangesNow?.();\n}\n/**\n * Allows a test `HarnessEnvironment` to install its own handler for auto change detection status\n * changes.\n * @param handler The handler for the auto change detection status.\n */\nfunction handleAutoChangeDetectionStatus(handler) {\n  stopHandlingAutoChangeDetectionStatus();\n  autoChangeDetectionSubscription = autoChangeDetectionSubject.subscribe(handler);\n}\n/** Allows a `HarnessEnvironment` to stop handling auto change detection status changes. */\nfunction stopHandlingAutoChangeDetectionStatus() {\n  autoChangeDetectionSubscription?.unsubscribe();\n  autoChangeDetectionSubscription = null;\n}\n/**\n * Batches together triggering of change detection over the duration of the given function.\n * @param fn The function to call with batched change detection.\n * @param triggerBeforeAndAfter Optionally trigger change detection once before and after the batch\n *   operation. If false, change detection will not be triggered.\n * @return The result of the given function.\n */\nfunction batchChangeDetection(_x, _x2) {\n  return _batchChangeDetection.apply(this, arguments);\n}\n/**\n * Disables the harness system's auto change detection for the duration of the given function.\n * @param fn The function to disable auto change detection for.\n * @return The result of the given function.\n */\nfunction _batchChangeDetection() {\n  _batchChangeDetection = _asyncToGenerator(function* (fn, triggerBeforeAndAfter) {\n    // If change detection batching is already in progress, just run the function.\n    if (autoChangeDetectionSubject.getValue().isDisabled) {\n      return yield fn();\n    }\n    // If nothing is handling change detection batching, install the default handler.\n    if (!autoChangeDetectionSubscription) {\n      handleAutoChangeDetectionStatus(defaultAutoChangeDetectionHandler);\n    }\n    if (triggerBeforeAndAfter) {\n      yield new Promise(resolve => autoChangeDetectionSubject.next({\n        isDisabled: true,\n        onDetectChangesNow: resolve\n      }));\n      // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n      // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n      // we wrap it in a `finally` block.\n      try {\n        return yield fn();\n      } finally {\n        yield new Promise(resolve => autoChangeDetectionSubject.next({\n          isDisabled: false,\n          onDetectChangesNow: resolve\n        }));\n      }\n    } else {\n      autoChangeDetectionSubject.next({\n        isDisabled: true\n      });\n      // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n      // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n      // we wrap it in a `finally` block.\n      try {\n        return yield fn();\n      } finally {\n        autoChangeDetectionSubject.next({\n          isDisabled: false\n        });\n      }\n    }\n  });\n  return _batchChangeDetection.apply(this, arguments);\n}\nfunction manualChangeDetection(_x3) {\n  return _manualChangeDetection.apply(this, arguments);\n}\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\nfunction _manualChangeDetection() {\n  _manualChangeDetection = _asyncToGenerator(function* (fn) {\n    return batchChangeDetection(fn, false);\n  });\n  return _manualChangeDetection.apply(this, arguments);\n}\nfunction parallel(_x4) {\n  return _parallel.apply(this, arguments);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Base class for component harnesses that all component harness authors should extend. This base\n * component harness provides the basic ability to locate element and sub-component harness. It\n * should be inherited when defining user's own harness.\n */\nfunction _parallel() {\n  _parallel = _asyncToGenerator(function* (values) {\n    return batchChangeDetection(() => Promise.all(values()), true);\n  });\n  return _parallel.apply(this, arguments);\n}\nclass ComponentHarness {\n  constructor(locatorFactory) {\n    this.locatorFactory = locatorFactory;\n  }\n  /** Gets a `Promise` for the `TestElement` representing the host element of the component. */\n  host() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.locatorFactory.rootElement;\n    })();\n  }\n  /**\n   * Gets a `LocatorFactory` for the document root element. This factory can be used to create\n   * locators for elements that a component creates outside of its own root element. (e.g. by\n   * appending to document.body).\n   */\n  documentRootLocatorFactory() {\n    return this.locatorFactory.documentRootLocatorFactory();\n  }\n  /**\n   * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n   * or element under the host element of this `ComponentHarness`.\n   * @param queries A list of queries specifying which harnesses and elements to search for:\n   *   - A `string` searches for elements matching the CSS selector specified by the string.\n   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n   *     given class.\n   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n   *     predicate.\n   * @return An asynchronous locator function that searches for and returns a `Promise` for the\n   *   first element or harness matching the given search criteria. Matches are ordered first by\n   *   order in the DOM, and second by order in the queries list. If no matches are found, the\n   *   `Promise` rejects. The type that the `Promise` resolves to is a union of all result types for\n   *   each query.\n   *\n   * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n   * `DivHarness.hostSelector === 'div'`:\n   * - `await ch.locatorFor(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n   * - `await ch.locatorFor('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n   * - `await ch.locatorFor('span')()` throws because the `Promise` rejects.\n   */\n  locatorFor(...queries) {\n    return this.locatorFactory.locatorFor(...queries);\n  }\n  /**\n   * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n   * or element under the host element of this `ComponentHarness`.\n   * @param queries A list of queries specifying which harnesses and elements to search for:\n   *   - A `string` searches for elements matching the CSS selector specified by the string.\n   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n   *     given class.\n   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n   *     predicate.\n   * @return An asynchronous locator function that searches for and returns a `Promise` for the\n   *   first element or harness matching the given search criteria. Matches are ordered first by\n   *   order in the DOM, and second by order in the queries list. If no matches are found, the\n   *   `Promise` is resolved with `null`. The type that the `Promise` resolves to is a union of all\n   *   result types for each query or null.\n   *\n   * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n   * `DivHarness.hostSelector === 'div'`:\n   * - `await ch.locatorForOptional(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n   * - `await ch.locatorForOptional('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n   * - `await ch.locatorForOptional('span')()` gets `null`.\n   */\n  locatorForOptional(...queries) {\n    return this.locatorFactory.locatorForOptional(...queries);\n  }\n  /**\n   * Creates an asynchronous locator function that can be used to find `ComponentHarness` instances\n   * or elements under the host element of this `ComponentHarness`.\n   * @param queries A list of queries specifying which harnesses and elements to search for:\n   *   - A `string` searches for elements matching the CSS selector specified by the string.\n   *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n   *     given class.\n   *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n   *     predicate.\n   * @return An asynchronous locator function that searches for and returns a `Promise` for all\n   *   elements and harnesses matching the given search criteria. Matches are ordered first by\n   *   order in the DOM, and second by order in the queries list. If an element matches more than\n   *   one `ComponentHarness` class, the locator gets an instance of each for the same element. If\n   *   an element matches multiple `string` selectors, only one `TestElement` instance is returned\n   *   for that element. The type that the `Promise` resolves to is an array where each element is\n   *   the union of all result types for each query.\n   *\n   * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n   * `DivHarness.hostSelector === 'div'` and `IdIsD1Harness.hostSelector === '#d1'`:\n   * - `await ch.locatorForAll(DivHarness, 'div')()` gets `[\n   *     DivHarness, // for #d1\n   *     TestElement, // for #d1\n   *     DivHarness, // for #d2\n   *     TestElement // for #d2\n   *   ]`\n   * - `await ch.locatorForAll('div', '#d1')()` gets `[\n   *     TestElement, // for #d1\n   *     TestElement // for #d2\n   *   ]`\n   * - `await ch.locatorForAll(DivHarness, IdIsD1Harness)()` gets `[\n   *     DivHarness, // for #d1\n   *     IdIsD1Harness, // for #d1\n   *     DivHarness // for #d2\n   *   ]`\n   * - `await ch.locatorForAll('span')()` gets `[]`.\n   */\n  locatorForAll(...queries) {\n    return this.locatorFactory.locatorForAll(...queries);\n  }\n  /**\n   * Flushes change detection and async tasks in the Angular zone.\n   * In most cases it should not be necessary to call this manually. However, there may be some edge\n   * cases where it is needed to fully flush animation events.\n   */\n  forceStabilize() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.locatorFactory.forceStabilize();\n    })();\n  }\n  /**\n   * Waits for all scheduled or running async tasks to complete. This allows harness\n   * authors to wait for async tasks outside of the Angular zone.\n   */\n  waitForTasksOutsideAngular() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3.locatorFactory.waitForTasksOutsideAngular();\n    })();\n  }\n}\n/**\n * Base class for component harnesses that authors should extend if they anticipate that consumers\n * of the harness may want to access other harnesses within the `<ng-content>` of the component.\n */\nclass ContentContainerComponentHarness extends ComponentHarness {\n  getChildLoader(selector) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this4.getRootHarnessLoader()).getChildLoader(selector);\n    })();\n  }\n  getAllChildLoaders(selector) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this5.getRootHarnessLoader()).getAllChildLoaders(selector);\n    })();\n  }\n  getHarness(query) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this6.getRootHarnessLoader()).getHarness(query);\n    })();\n  }\n  getHarnessOrNull(query) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this7.getRootHarnessLoader()).getHarnessOrNull(query);\n    })();\n  }\n  getAllHarnesses(query) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this8.getRootHarnessLoader()).getAllHarnesses(query);\n    })();\n  }\n  hasHarness(query) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this9.getRootHarnessLoader()).hasHarness(query);\n    })();\n  }\n  /**\n   * Gets the root harness loader from which to start\n   * searching for content contained by this harness.\n   */\n  getRootHarnessLoader() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      return _this10.locatorFactory.rootHarnessLoader();\n    })();\n  }\n}\n/**\n * A class used to associate a ComponentHarness class with predicates functions that can be used to\n * filter instances of the class.\n */\nclass HarnessPredicate {\n  constructor(harnessType, options) {\n    this.harnessType = harnessType;\n    this._predicates = [];\n    this._descriptions = [];\n    this._addBaseOptions(options);\n  }\n  /**\n   * Checks if the specified nullable string value matches the given pattern.\n   * @param value The nullable string value to check, or a Promise resolving to the\n   *   nullable string value.\n   * @param pattern The pattern the value is expected to match. If `pattern` is a string,\n   *   `value` is expected to match exactly. If `pattern` is a regex, a partial match is\n   *   allowed. If `pattern` is `null`, the value is expected to be `null`.\n   * @return Whether the value matches the pattern.\n   */\n  static stringMatches(value, pattern) {\n    return _asyncToGenerator(function* () {\n      value = yield value;\n      if (pattern === null) {\n        return value === null;\n      } else if (value === null) {\n        return false;\n      }\n      return typeof pattern === 'string' ? value === pattern : pattern.test(value);\n    })();\n  }\n  /**\n   * Adds a predicate function to be run against candidate harnesses.\n   * @param description A description of this predicate that may be used in error messages.\n   * @param predicate An async predicate function.\n   * @return this (for method chaining).\n   */\n  add(description, predicate) {\n    this._descriptions.push(description);\n    this._predicates.push(predicate);\n    return this;\n  }\n  /**\n   * Adds a predicate function that depends on an option value to be run against candidate\n   * harnesses. If the option value is undefined, the predicate will be ignored.\n   * @param name The name of the option (may be used in error messages).\n   * @param option The option value.\n   * @param predicate The predicate function to run if the option value is not undefined.\n   * @return this (for method chaining).\n   */\n  addOption(name, option, predicate) {\n    if (option !== undefined) {\n      this.add(`${name} = ${_valueAsString(option)}`, item => predicate(item, option));\n    }\n    return this;\n  }\n  /**\n   * Filters a list of harnesses on this predicate.\n   * @param harnesses The list of harnesses to filter.\n   * @return A list of harnesses that satisfy this predicate.\n   */\n  filter(harnesses) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (harnesses.length === 0) {\n        return [];\n      }\n      const results = yield parallel(() => harnesses.map(h => _this11.evaluate(h)));\n      return harnesses.filter((_, i) => results[i]);\n    })();\n  }\n  /**\n   * Evaluates whether the given harness satisfies this predicate.\n   * @param harness The harness to check\n   * @return A promise that resolves to true if the harness satisfies this predicate,\n   *   and resolves to false otherwise.\n   */\n  evaluate(harness) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const results = yield parallel(() => _this12._predicates.map(p => p(harness)));\n      return results.reduce((combined, current) => combined && current, true);\n    })();\n  }\n  /** Gets a description of this predicate for use in error messages. */\n  getDescription() {\n    return this._descriptions.join(', ');\n  }\n  /** Gets the selector used to find candidate elements. */\n  getSelector() {\n    // We don't have to go through the extra trouble if there are no ancestors.\n    if (!this._ancestor) {\n      return (this.harnessType.hostSelector || '').trim();\n    }\n    const [ancestors, ancestorPlaceholders] = _splitAndEscapeSelector(this._ancestor);\n    const [selectors, selectorPlaceholders] = _splitAndEscapeSelector(this.harnessType.hostSelector || '');\n    const result = [];\n    // We have to add the ancestor to each part of the host compound selector, otherwise we can get\n    // incorrect results. E.g. `.ancestor .a, .ancestor .b` vs `.ancestor .a, .b`.\n    ancestors.forEach(escapedAncestor => {\n      const ancestor = _restoreSelector(escapedAncestor, ancestorPlaceholders);\n      return selectors.forEach(escapedSelector => result.push(`${ancestor} ${_restoreSelector(escapedSelector, selectorPlaceholders)}`));\n    });\n    return result.join(', ');\n  }\n  /** Adds base options common to all harness types. */\n  _addBaseOptions(options) {\n    this._ancestor = options.ancestor || '';\n    if (this._ancestor) {\n      this._descriptions.push(`has ancestor matching selector \"${this._ancestor}\"`);\n    }\n    const selector = options.selector;\n    if (selector !== undefined) {\n      this.add(`host matches selector \"${selector}\"`, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (item) {\n          return (yield item.host()).matchesSelector(selector);\n        });\n        return function (_x5) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n  }\n}\n/** Represent a value as a string for the purpose of logging. */\nfunction _valueAsString(value) {\n  if (value === undefined) {\n    return 'undefined';\n  }\n  try {\n    // `JSON.stringify` doesn't handle RegExp properly, so we need a custom replacer.\n    // Use a character that is unlikely to appear in real strings to denote the start and end of\n    // the regex. This allows us to strip out the extra quotes around the value added by\n    // `JSON.stringify`. Also do custom escaping on `\"` characters to prevent `JSON.stringify`\n    // from escaping them as if they were part of a string.\n    const stringifiedValue = JSON.stringify(value, (_, v) => v instanceof RegExp ? `◬MAT_RE_ESCAPE◬${v.toString().replace(/\"/g, '◬MAT_RE_ESCAPE◬')}◬MAT_RE_ESCAPE◬` : v);\n    // Strip out the extra quotes around regexes and put back the manually escaped `\"` characters.\n    return stringifiedValue.replace(/\"◬MAT_RE_ESCAPE◬|◬MAT_RE_ESCAPE◬\"/g, '').replace(/◬MAT_RE_ESCAPE◬/g, '\"');\n  } catch {\n    // `JSON.stringify` will throw if the object is cyclical,\n    // in this case the best we can do is report the value as `{...}`.\n    return '{...}';\n  }\n}\n/**\n * Splits up a compound selector into its parts and escapes any quoted content. The quoted content\n * has to be escaped, because it can contain commas which will throw throw us off when trying to\n * split it.\n * @param selector Selector to be split.\n * @returns The escaped string where any quoted content is replaced with a placeholder. E.g.\n * `[foo=\"bar\"]` turns into `[foo=__cdkPlaceholder-0__]`. Use `_restoreSelector` to restore\n * the placeholders.\n */\nfunction _splitAndEscapeSelector(selector) {\n  const placeholders = [];\n  // Note that the regex doesn't account for nested quotes so something like `\"ab'cd'e\"` will be\n  // considered as two blocks. It's a bit of an edge case, but if we find that it's a problem,\n  // we can make it a bit smarter using a loop. Use this for now since it's more readable and\n  // compact. More complete implementation:\n  // https://github.com/angular/angular/blob/bd34bc9e89f18a/packages/compiler/src/shadow_css.ts#L655\n  const result = selector.replace(/([\"'][^[\"']*[\"'])/g, (_, keep) => {\n    const replaceBy = `__cdkPlaceholder-${placeholders.length}__`;\n    placeholders.push(keep);\n    return replaceBy;\n  });\n  return [result.split(',').map(part => part.trim()), placeholders];\n}\n/** Restores a selector whose content was escaped in `_splitAndEscapeSelector`. */\nfunction _restoreSelector(selector, placeholders) {\n  return selector.replace(/__cdkPlaceholder-(\\d+)__/g, (_, index) => placeholders[+index]);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Base harness environment class that can be extended to allow `ComponentHarness`es to be used in\n * different test environments (e.g. testbed, protractor, etc.). This class implements the\n * functionality of both a `HarnessLoader` and `LocatorFactory`. This class is generic on the raw\n * element type, `E`, used by the particular test environment.\n */\nclass HarnessEnvironment {\n  // Implemented as part of the `LocatorFactory` interface.\n  get rootElement() {\n    this._rootElement = this._rootElement || this.createTestElement(this.rawRootElement);\n    return this._rootElement;\n  }\n  set rootElement(element) {\n    this._rootElement = element;\n  }\n  constructor(rawRootElement) {\n    this.rawRootElement = rawRootElement;\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  documentRootLocatorFactory() {\n    return this.createEnvironment(this.getDocumentRoot());\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  locatorFor(...queries) {\n    return () => _assertResultFound(this._getAllHarnessesAndTestElements(queries), _getDescriptionForLocatorForQueries(queries));\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  locatorForOptional(...queries) {\n    var _this13 = this;\n    return /*#__PURE__*/_asyncToGenerator(function* () {\n      return (yield _this13._getAllHarnessesAndTestElements(queries))[0] || null;\n    });\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  locatorForAll(...queries) {\n    return () => this._getAllHarnessesAndTestElements(queries);\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  rootHarnessLoader() {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      return _this14;\n    })();\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  harnessLoaderFor(selector) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      return _this15.createEnvironment(yield _assertResultFound(_this15.getAllRawElements(selector), [_getDescriptionForHarnessLoaderQuery(selector)]));\n    })();\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  harnessLoaderForOptional(selector) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const elements = yield _this16.getAllRawElements(selector);\n      return elements[0] ? _this16.createEnvironment(elements[0]) : null;\n    })();\n  }\n  // Implemented as part of the `LocatorFactory` interface.\n  harnessLoaderForAll(selector) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const elements = yield _this17.getAllRawElements(selector);\n      return elements.map(element => _this17.createEnvironment(element));\n    })();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  getHarness(query) {\n    return this.locatorFor(query)();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  getHarnessOrNull(query) {\n    return this.locatorForOptional(query)();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  getAllHarnesses(query) {\n    return this.locatorForAll(query)();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  hasHarness(query) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this18.locatorForOptional(query)()) !== null;\n    })();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  getChildLoader(selector) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      return _this19.createEnvironment(yield _assertResultFound(_this19.getAllRawElements(selector), [_getDescriptionForHarnessLoaderQuery(selector)]));\n    })();\n  }\n  // Implemented as part of the `HarnessLoader` interface.\n  getAllChildLoaders(selector) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this20.getAllRawElements(selector)).map(e => _this20.createEnvironment(e));\n    })();\n  }\n  /** Creates a `ComponentHarness` for the given harness type with the given raw host element. */\n  createComponentHarness(harnessType, element) {\n    return new harnessType(this.createEnvironment(element));\n  }\n  /**\n   * Matches the given raw elements with the given list of element and harness queries to produce a\n   * list of matched harnesses and test elements.\n   */\n  _getAllHarnessesAndTestElements(queries) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      if (!queries.length) {\n        throw Error('CDK Component harness query must contain at least one element.');\n      }\n      const {\n        allQueries,\n        harnessQueries,\n        elementQueries,\n        harnessTypes\n      } = _parseQueries(queries);\n      // Combine all of the queries into one large comma-delimited selector and use it to get all raw\n      // elements matching any of the individual queries.\n      const rawElements = yield _this21.getAllRawElements([...elementQueries, ...harnessQueries.map(predicate => predicate.getSelector())].join(','));\n      // If every query is searching for the same harness subclass, we know every result corresponds\n      // to an instance of that subclass. Likewise, if every query is for a `TestElement`, we know\n      // every result corresponds to a `TestElement`. Otherwise we need to verify which result was\n      // found by which selector so it can be matched to the appropriate instance.\n      const skipSelectorCheck = elementQueries.length === 0 && harnessTypes.size === 1 || harnessQueries.length === 0;\n      const perElementMatches = yield parallel(() => rawElements.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (rawElement) {\n          const testElement = _this21.createTestElement(rawElement);\n          const allResultsForElement = yield parallel(\n          // For each query, get `null` if it doesn't match, or a `TestElement` or\n          // `ComponentHarness` as appropriate if it does match. This gives us everything that\n          // matches the current raw element, but it may contain duplicate entries (e.g.\n          // multiple `TestElement` or multiple `ComponentHarness` of the same type).\n          () => allQueries.map(query => _this21._getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck)));\n          return _removeDuplicateQueryResults(allResultsForElement);\n        });\n        return function (_x6) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n      return [].concat(...perElementMatches);\n    })();\n  }\n  /**\n   * Check whether the given query matches the given element, if it does return the matched\n   * `TestElement` or `ComponentHarness`, if it does not, return null. In cases where the caller\n   * knows for sure that the query matches the element's selector, `skipSelectorCheck` can be used\n   * to skip verification and optimize performance.\n   */\n  _getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck = false) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      if (typeof query === 'string') {\n        return skipSelectorCheck || (yield testElement.matchesSelector(query)) ? testElement : null;\n      }\n      if (skipSelectorCheck || (yield testElement.matchesSelector(query.getSelector()))) {\n        const harness = _this22.createComponentHarness(query.harnessType, rawElement);\n        return (yield query.evaluate(harness)) ? harness : null;\n      }\n      return null;\n    })();\n  }\n}\n/**\n * Parses a list of queries in the format accepted by the `locatorFor*` methods into an easier to\n * work with format.\n */\nfunction _parseQueries(queries) {\n  const allQueries = [];\n  const harnessQueries = [];\n  const elementQueries = [];\n  const harnessTypes = new Set();\n  for (const query of queries) {\n    if (typeof query === 'string') {\n      allQueries.push(query);\n      elementQueries.push(query);\n    } else {\n      const predicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n      allQueries.push(predicate);\n      harnessQueries.push(predicate);\n      harnessTypes.add(predicate.harnessType);\n    }\n  }\n  return {\n    allQueries,\n    harnessQueries,\n    elementQueries,\n    harnessTypes\n  };\n}\n/**\n * Removes duplicate query results for a particular element. (e.g. multiple `TestElement`\n * instances or multiple instances of the same `ComponentHarness` class.\n */\nfunction _removeDuplicateQueryResults(_x7) {\n  return _removeDuplicateQueryResults2.apply(this, arguments);\n}\n/** Verifies that there is at least one result in an array. */\nfunction _removeDuplicateQueryResults2() {\n  _removeDuplicateQueryResults2 = _asyncToGenerator(function* (results) {\n    let testElementMatched = false;\n    let matchedHarnessTypes = new Set();\n    const dedupedMatches = [];\n    for (const result of results) {\n      if (!result) {\n        continue;\n      }\n      if (result instanceof ComponentHarness) {\n        if (!matchedHarnessTypes.has(result.constructor)) {\n          matchedHarnessTypes.add(result.constructor);\n          dedupedMatches.push(result);\n        }\n      } else if (!testElementMatched) {\n        testElementMatched = true;\n        dedupedMatches.push(result);\n      }\n    }\n    return dedupedMatches;\n  });\n  return _removeDuplicateQueryResults2.apply(this, arguments);\n}\nfunction _assertResultFound(_x8, _x9) {\n  return _assertResultFound2.apply(this, arguments);\n}\n/** Gets a list of description strings from a list of queries. */\nfunction _assertResultFound2() {\n  _assertResultFound2 = _asyncToGenerator(function* (results, queryDescriptions) {\n    const result = (yield results)[0];\n    if (result == undefined) {\n      throw Error(`Failed to find element matching one of the following queries:\\n` + queryDescriptions.map(desc => `(${desc})`).join(',\\n'));\n    }\n    return result;\n  });\n  return _assertResultFound2.apply(this, arguments);\n}\nfunction _getDescriptionForLocatorForQueries(queries) {\n  return queries.map(query => typeof query === 'string' ? _getDescriptionForTestElementQuery(query) : _getDescriptionForComponentHarnessQuery(query));\n}\n/** Gets a description string for a `ComponentHarness` query. */\nfunction _getDescriptionForComponentHarnessQuery(query) {\n  const harnessPredicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n  const {\n    name,\n    hostSelector\n  } = harnessPredicate.harnessType;\n  const description = `${name} with host element matching selector: \"${hostSelector}\"`;\n  const constraints = harnessPredicate.getDescription();\n  return description + (constraints ? ` satisfying the constraints: ${harnessPredicate.getDescription()}` : '');\n}\n/** Gets a description string for a `TestElement` query. */\nfunction _getDescriptionForTestElementQuery(selector) {\n  return `TestElement for element matching selector: \"${selector}\"`;\n}\n/** Gets a description string for a `HarnessLoader` query. */\nfunction _getDescriptionForHarnessLoaderQuery(selector) {\n  return `HarnessLoader for element matching selector: \"${selector}\"`;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** An enum of non-text keys that can be used with the `sendKeys` method. */\n// NOTE: This is a separate enum from `@angular/cdk/keycodes` because we don't necessarily want to\n// support every possible keyCode. We also can't rely on Protractor's `Key` because we don't want a\n// dependency on any particular testing framework here. Instead we'll just maintain this supported\n// list of keys and let individual concrete `HarnessEnvironment` classes map them to whatever key\n// representation is used in its respective testing framework.\n// tslint:disable-next-line:prefer-const-enum Seems like this causes some issues with System.js\nvar TestKey;\n(function (TestKey) {\n  TestKey[TestKey[\"BACKSPACE\"] = 0] = \"BACKSPACE\";\n  TestKey[TestKey[\"TAB\"] = 1] = \"TAB\";\n  TestKey[TestKey[\"ENTER\"] = 2] = \"ENTER\";\n  TestKey[TestKey[\"SHIFT\"] = 3] = \"SHIFT\";\n  TestKey[TestKey[\"CONTROL\"] = 4] = \"CONTROL\";\n  TestKey[TestKey[\"ALT\"] = 5] = \"ALT\";\n  TestKey[TestKey[\"ESCAPE\"] = 6] = \"ESCAPE\";\n  TestKey[TestKey[\"PAGE_UP\"] = 7] = \"PAGE_UP\";\n  TestKey[TestKey[\"PAGE_DOWN\"] = 8] = \"PAGE_DOWN\";\n  TestKey[TestKey[\"END\"] = 9] = \"END\";\n  TestKey[TestKey[\"HOME\"] = 10] = \"HOME\";\n  TestKey[TestKey[\"LEFT_ARROW\"] = 11] = \"LEFT_ARROW\";\n  TestKey[TestKey[\"UP_ARROW\"] = 12] = \"UP_ARROW\";\n  TestKey[TestKey[\"RIGHT_ARROW\"] = 13] = \"RIGHT_ARROW\";\n  TestKey[TestKey[\"DOWN_ARROW\"] = 14] = \"DOWN_ARROW\";\n  TestKey[TestKey[\"INSERT\"] = 15] = \"INSERT\";\n  TestKey[TestKey[\"DELETE\"] = 16] = \"DELETE\";\n  TestKey[TestKey[\"F1\"] = 17] = \"F1\";\n  TestKey[TestKey[\"F2\"] = 18] = \"F2\";\n  TestKey[TestKey[\"F3\"] = 19] = \"F3\";\n  TestKey[TestKey[\"F4\"] = 20] = \"F4\";\n  TestKey[TestKey[\"F5\"] = 21] = \"F5\";\n  TestKey[TestKey[\"F6\"] = 22] = \"F6\";\n  TestKey[TestKey[\"F7\"] = 23] = \"F7\";\n  TestKey[TestKey[\"F8\"] = 24] = \"F8\";\n  TestKey[TestKey[\"F9\"] = 25] = \"F9\";\n  TestKey[TestKey[\"F10\"] = 26] = \"F10\";\n  TestKey[TestKey[\"F11\"] = 27] = \"F11\";\n  TestKey[TestKey[\"F12\"] = 28] = \"F12\";\n  TestKey[TestKey[\"META\"] = 29] = \"META\";\n})(TestKey || (TestKey = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an error which reports that no keys have been specified.\n * @docs-private\n */\nfunction getNoKeysSpecifiedError() {\n  return Error('No keys have been specified.');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Gets text of element excluding certain selectors within the element.\n * @param element Element to get text from,\n * @param excludeSelector Selector identifying which elements to exclude,\n */\nfunction _getTextWithExcludedElements(element, excludeSelector) {\n  const clone = element.cloneNode(true);\n  const exclusions = clone.querySelectorAll(excludeSelector);\n  for (let i = 0; i < exclusions.length; i++) {\n    exclusions[i].remove();\n  }\n  return (clone.textContent || '').trim();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport { ComponentHarness, ContentContainerComponentHarness, HarnessEnvironment, HarnessPredicate, TestKey, _getTextWithExcludedElements, getNoKeysSpecifiedError, handleAutoChangeDetectionStatus, manualChangeDetection, parallel, stopHandlingAutoChangeDetectionStatus };","map":{"version":3,"names":["BehaviorSubject","autoChangeDetectionSubject","isDisabled","autoChangeDetectionSubscription","defaultAutoChangeDetectionHandler","status","onDetectChangesNow","handleAutoChangeDetectionStatus","handler","stopHandlingAutoChangeDetectionStatus","subscribe","unsubscribe","batchChangeDetection","fn","triggerBeforeAndAfter","getValue","Promise","resolve","next","manualChangeDetection","parallel","values","all","ComponentHarness","constructor","locatorFactory","host","rootElement","documentRootLocatorFactory","locatorFor","queries","locatorForOptional","locatorForAll","forceStabilize","waitForTasksOutsideAngular","ContentContainerComponentHarness","getChildLoader","selector","getRootHarnessLoader","getAllChildLoaders","getHarness","query","getHarnessOrNull","getAllHarnesses","hasHarness","rootHarnessLoader","HarnessPredicate","harnessType","options","_predicates","_descriptions","_addBaseOptions","stringMatches","value","pattern","test","add","description","predicate","push","addOption","name","option","undefined","_valueAsString","item","filter","harnesses","length","results","map","h","evaluate","_","i","harness","p","reduce","combined","current","getDescription","join","getSelector","_ancestor","hostSelector","trim","ancestors","ancestorPlaceholders","_splitAndEscapeSelector","selectors","selectorPlaceholders","result","forEach","escapedAncestor","ancestor","_restoreSelector","escapedSelector","matchesSelector","stringifiedValue","JSON","stringify","v","RegExp","toString","replace","placeholders","keep","replaceBy","split","part","index","HarnessEnvironment","_rootElement","createTestElement","rawRootElement","element","createEnvironment","getDocumentRoot","_assertResultFound","_getAllHarnessesAndTestElements","_getDescriptionForLocatorForQueries","harnessLoaderFor","getAllRawElements","_getDescriptionForHarnessLoaderQuery","harnessLoaderForOptional","elements","harnessLoaderForAll","e","createComponentHarness","Error","allQueries","harnessQueries","elementQueries","harnessTypes","_parseQueries","rawElements","skipSelectorCheck","size","perElementMatches","rawElement","testElement","allResultsForElement","_getQueryResultForElement","_removeDuplicateQueryResults","concat","Set","testElementMatched","matchedHarnessTypes","dedupedMatches","has","queryDescriptions","desc","_getDescriptionForTestElementQuery","_getDescriptionForComponentHarnessQuery","harnessPredicate","constraints","TestKey","getNoKeysSpecifiedError","_getTextWithExcludedElements","excludeSelector","clone","cloneNode","exclusions","querySelectorAll","remove","textContent"],"sources":["C:/angular/front-app-angular-arielle/node_modules/@angular/cdk/fesm2020/testing.mjs"],"sourcesContent":["import { BehaviorSubject } from 'rxjs';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Subject used to dispatch and listen for changes to the auto change detection status . */\nconst autoChangeDetectionSubject = new BehaviorSubject({\n    isDisabled: false,\n});\n/** The current subscription to `autoChangeDetectionSubject`. */\nlet autoChangeDetectionSubscription;\n/**\n * The default handler for auto change detection status changes. This handler will be used if the\n * specific environment does not install its own.\n * @param status The new auto change detection status.\n */\nfunction defaultAutoChangeDetectionHandler(status) {\n    status.onDetectChangesNow?.();\n}\n/**\n * Allows a test `HarnessEnvironment` to install its own handler for auto change detection status\n * changes.\n * @param handler The handler for the auto change detection status.\n */\nfunction handleAutoChangeDetectionStatus(handler) {\n    stopHandlingAutoChangeDetectionStatus();\n    autoChangeDetectionSubscription = autoChangeDetectionSubject.subscribe(handler);\n}\n/** Allows a `HarnessEnvironment` to stop handling auto change detection status changes. */\nfunction stopHandlingAutoChangeDetectionStatus() {\n    autoChangeDetectionSubscription?.unsubscribe();\n    autoChangeDetectionSubscription = null;\n}\n/**\n * Batches together triggering of change detection over the duration of the given function.\n * @param fn The function to call with batched change detection.\n * @param triggerBeforeAndAfter Optionally trigger change detection once before and after the batch\n *   operation. If false, change detection will not be triggered.\n * @return The result of the given function.\n */\nasync function batchChangeDetection(fn, triggerBeforeAndAfter) {\n    // If change detection batching is already in progress, just run the function.\n    if (autoChangeDetectionSubject.getValue().isDisabled) {\n        return await fn();\n    }\n    // If nothing is handling change detection batching, install the default handler.\n    if (!autoChangeDetectionSubscription) {\n        handleAutoChangeDetectionStatus(defaultAutoChangeDetectionHandler);\n    }\n    if (triggerBeforeAndAfter) {\n        await new Promise(resolve => autoChangeDetectionSubject.next({\n            isDisabled: true,\n            onDetectChangesNow: resolve,\n        }));\n        // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n        // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n        // we wrap it in a `finally` block.\n        try {\n            return await fn();\n        }\n        finally {\n            await new Promise(resolve => autoChangeDetectionSubject.next({\n                isDisabled: false,\n                onDetectChangesNow: resolve,\n            }));\n        }\n    }\n    else {\n        autoChangeDetectionSubject.next({ isDisabled: true });\n        // The function passed in may throw (e.g. if the user wants to make an expectation of an error\n        // being thrown. If this happens, we need to make sure we still re-enable change detection, so\n        // we wrap it in a `finally` block.\n        try {\n            return await fn();\n        }\n        finally {\n            autoChangeDetectionSubject.next({ isDisabled: false });\n        }\n    }\n}\n/**\n * Disables the harness system's auto change detection for the duration of the given function.\n * @param fn The function to disable auto change detection for.\n * @return The result of the given function.\n */\nasync function manualChangeDetection(fn) {\n    return batchChangeDetection(fn, false);\n}\n/**\n * Resolves the given list of async values in parallel (i.e. via Promise.all) while batching change\n * detection over the entire operation such that change detection occurs exactly once before\n * resolving the values and once after.\n * @param values A getter for the async values to resolve in parallel with batched change detection.\n * @return The resolved values.\n */\nasync function parallel(values) {\n    return batchChangeDetection(() => Promise.all(values()), true);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Base class for component harnesses that all component harness authors should extend. This base\n * component harness provides the basic ability to locate element and sub-component harness. It\n * should be inherited when defining user's own harness.\n */\nclass ComponentHarness {\n    constructor(locatorFactory) {\n        this.locatorFactory = locatorFactory;\n    }\n    /** Gets a `Promise` for the `TestElement` representing the host element of the component. */\n    async host() {\n        return this.locatorFactory.rootElement;\n    }\n    /**\n     * Gets a `LocatorFactory` for the document root element. This factory can be used to create\n     * locators for elements that a component creates outside of its own root element. (e.g. by\n     * appending to document.body).\n     */\n    documentRootLocatorFactory() {\n        return this.locatorFactory.documentRootLocatorFactory();\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` rejects. The type that the `Promise` resolves to is a union of all result types for\n     *   each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await ch.locatorFor(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await ch.locatorFor('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await ch.locatorFor('span')()` throws because the `Promise` rejects.\n     */\n    locatorFor(...queries) {\n        return this.locatorFactory.locatorFor(...queries);\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find a `ComponentHarness` instance\n     * or element under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for the\n     *   first element or harness matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If no matches are found, the\n     *   `Promise` is resolved with `null`. The type that the `Promise` resolves to is a union of all\n     *   result types for each query or null.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'`:\n     * - `await ch.locatorForOptional(DivHarness, 'div')()` gets a `DivHarness` instance for `#d1`\n     * - `await ch.locatorForOptional('div', DivHarness)()` gets a `TestElement` instance for `#d1`\n     * - `await ch.locatorForOptional('span')()` gets `null`.\n     */\n    locatorForOptional(...queries) {\n        return this.locatorFactory.locatorForOptional(...queries);\n    }\n    /**\n     * Creates an asynchronous locator function that can be used to find `ComponentHarness` instances\n     * or elements under the host element of this `ComponentHarness`.\n     * @param queries A list of queries specifying which harnesses and elements to search for:\n     *   - A `string` searches for elements matching the CSS selector specified by the string.\n     *   - A `ComponentHarness` constructor searches for `ComponentHarness` instances matching the\n     *     given class.\n     *   - A `HarnessPredicate` searches for `ComponentHarness` instances matching the given\n     *     predicate.\n     * @return An asynchronous locator function that searches for and returns a `Promise` for all\n     *   elements and harnesses matching the given search criteria. Matches are ordered first by\n     *   order in the DOM, and second by order in the queries list. If an element matches more than\n     *   one `ComponentHarness` class, the locator gets an instance of each for the same element. If\n     *   an element matches multiple `string` selectors, only one `TestElement` instance is returned\n     *   for that element. The type that the `Promise` resolves to is an array where each element is\n     *   the union of all result types for each query.\n     *\n     * e.g. Given the following DOM: `<div id=\"d1\" /><div id=\"d2\" />`, and assuming\n     * `DivHarness.hostSelector === 'div'` and `IdIsD1Harness.hostSelector === '#d1'`:\n     * - `await ch.locatorForAll(DivHarness, 'div')()` gets `[\n     *     DivHarness, // for #d1\n     *     TestElement, // for #d1\n     *     DivHarness, // for #d2\n     *     TestElement // for #d2\n     *   ]`\n     * - `await ch.locatorForAll('div', '#d1')()` gets `[\n     *     TestElement, // for #d1\n     *     TestElement // for #d2\n     *   ]`\n     * - `await ch.locatorForAll(DivHarness, IdIsD1Harness)()` gets `[\n     *     DivHarness, // for #d1\n     *     IdIsD1Harness, // for #d1\n     *     DivHarness // for #d2\n     *   ]`\n     * - `await ch.locatorForAll('span')()` gets `[]`.\n     */\n    locatorForAll(...queries) {\n        return this.locatorFactory.locatorForAll(...queries);\n    }\n    /**\n     * Flushes change detection and async tasks in the Angular zone.\n     * In most cases it should not be necessary to call this manually. However, there may be some edge\n     * cases where it is needed to fully flush animation events.\n     */\n    async forceStabilize() {\n        return this.locatorFactory.forceStabilize();\n    }\n    /**\n     * Waits for all scheduled or running async tasks to complete. This allows harness\n     * authors to wait for async tasks outside of the Angular zone.\n     */\n    async waitForTasksOutsideAngular() {\n        return this.locatorFactory.waitForTasksOutsideAngular();\n    }\n}\n/**\n * Base class for component harnesses that authors should extend if they anticipate that consumers\n * of the harness may want to access other harnesses within the `<ng-content>` of the component.\n */\nclass ContentContainerComponentHarness extends ComponentHarness {\n    async getChildLoader(selector) {\n        return (await this.getRootHarnessLoader()).getChildLoader(selector);\n    }\n    async getAllChildLoaders(selector) {\n        return (await this.getRootHarnessLoader()).getAllChildLoaders(selector);\n    }\n    async getHarness(query) {\n        return (await this.getRootHarnessLoader()).getHarness(query);\n    }\n    async getHarnessOrNull(query) {\n        return (await this.getRootHarnessLoader()).getHarnessOrNull(query);\n    }\n    async getAllHarnesses(query) {\n        return (await this.getRootHarnessLoader()).getAllHarnesses(query);\n    }\n    async hasHarness(query) {\n        return (await this.getRootHarnessLoader()).hasHarness(query);\n    }\n    /**\n     * Gets the root harness loader from which to start\n     * searching for content contained by this harness.\n     */\n    async getRootHarnessLoader() {\n        return this.locatorFactory.rootHarnessLoader();\n    }\n}\n/**\n * A class used to associate a ComponentHarness class with predicates functions that can be used to\n * filter instances of the class.\n */\nclass HarnessPredicate {\n    constructor(harnessType, options) {\n        this.harnessType = harnessType;\n        this._predicates = [];\n        this._descriptions = [];\n        this._addBaseOptions(options);\n    }\n    /**\n     * Checks if the specified nullable string value matches the given pattern.\n     * @param value The nullable string value to check, or a Promise resolving to the\n     *   nullable string value.\n     * @param pattern The pattern the value is expected to match. If `pattern` is a string,\n     *   `value` is expected to match exactly. If `pattern` is a regex, a partial match is\n     *   allowed. If `pattern` is `null`, the value is expected to be `null`.\n     * @return Whether the value matches the pattern.\n     */\n    static async stringMatches(value, pattern) {\n        value = await value;\n        if (pattern === null) {\n            return value === null;\n        }\n        else if (value === null) {\n            return false;\n        }\n        return typeof pattern === 'string' ? value === pattern : pattern.test(value);\n    }\n    /**\n     * Adds a predicate function to be run against candidate harnesses.\n     * @param description A description of this predicate that may be used in error messages.\n     * @param predicate An async predicate function.\n     * @return this (for method chaining).\n     */\n    add(description, predicate) {\n        this._descriptions.push(description);\n        this._predicates.push(predicate);\n        return this;\n    }\n    /**\n     * Adds a predicate function that depends on an option value to be run against candidate\n     * harnesses. If the option value is undefined, the predicate will be ignored.\n     * @param name The name of the option (may be used in error messages).\n     * @param option The option value.\n     * @param predicate The predicate function to run if the option value is not undefined.\n     * @return this (for method chaining).\n     */\n    addOption(name, option, predicate) {\n        if (option !== undefined) {\n            this.add(`${name} = ${_valueAsString(option)}`, item => predicate(item, option));\n        }\n        return this;\n    }\n    /**\n     * Filters a list of harnesses on this predicate.\n     * @param harnesses The list of harnesses to filter.\n     * @return A list of harnesses that satisfy this predicate.\n     */\n    async filter(harnesses) {\n        if (harnesses.length === 0) {\n            return [];\n        }\n        const results = await parallel(() => harnesses.map(h => this.evaluate(h)));\n        return harnesses.filter((_, i) => results[i]);\n    }\n    /**\n     * Evaluates whether the given harness satisfies this predicate.\n     * @param harness The harness to check\n     * @return A promise that resolves to true if the harness satisfies this predicate,\n     *   and resolves to false otherwise.\n     */\n    async evaluate(harness) {\n        const results = await parallel(() => this._predicates.map(p => p(harness)));\n        return results.reduce((combined, current) => combined && current, true);\n    }\n    /** Gets a description of this predicate for use in error messages. */\n    getDescription() {\n        return this._descriptions.join(', ');\n    }\n    /** Gets the selector used to find candidate elements. */\n    getSelector() {\n        // We don't have to go through the extra trouble if there are no ancestors.\n        if (!this._ancestor) {\n            return (this.harnessType.hostSelector || '').trim();\n        }\n        const [ancestors, ancestorPlaceholders] = _splitAndEscapeSelector(this._ancestor);\n        const [selectors, selectorPlaceholders] = _splitAndEscapeSelector(this.harnessType.hostSelector || '');\n        const result = [];\n        // We have to add the ancestor to each part of the host compound selector, otherwise we can get\n        // incorrect results. E.g. `.ancestor .a, .ancestor .b` vs `.ancestor .a, .b`.\n        ancestors.forEach(escapedAncestor => {\n            const ancestor = _restoreSelector(escapedAncestor, ancestorPlaceholders);\n            return selectors.forEach(escapedSelector => result.push(`${ancestor} ${_restoreSelector(escapedSelector, selectorPlaceholders)}`));\n        });\n        return result.join(', ');\n    }\n    /** Adds base options common to all harness types. */\n    _addBaseOptions(options) {\n        this._ancestor = options.ancestor || '';\n        if (this._ancestor) {\n            this._descriptions.push(`has ancestor matching selector \"${this._ancestor}\"`);\n        }\n        const selector = options.selector;\n        if (selector !== undefined) {\n            this.add(`host matches selector \"${selector}\"`, async (item) => {\n                return (await item.host()).matchesSelector(selector);\n            });\n        }\n    }\n}\n/** Represent a value as a string for the purpose of logging. */\nfunction _valueAsString(value) {\n    if (value === undefined) {\n        return 'undefined';\n    }\n    try {\n        // `JSON.stringify` doesn't handle RegExp properly, so we need a custom replacer.\n        // Use a character that is unlikely to appear in real strings to denote the start and end of\n        // the regex. This allows us to strip out the extra quotes around the value added by\n        // `JSON.stringify`. Also do custom escaping on `\"` characters to prevent `JSON.stringify`\n        // from escaping them as if they were part of a string.\n        const stringifiedValue = JSON.stringify(value, (_, v) => v instanceof RegExp\n            ? `◬MAT_RE_ESCAPE◬${v.toString().replace(/\"/g, '◬MAT_RE_ESCAPE◬')}◬MAT_RE_ESCAPE◬`\n            : v);\n        // Strip out the extra quotes around regexes and put back the manually escaped `\"` characters.\n        return stringifiedValue\n            .replace(/\"◬MAT_RE_ESCAPE◬|◬MAT_RE_ESCAPE◬\"/g, '')\n            .replace(/◬MAT_RE_ESCAPE◬/g, '\"');\n    }\n    catch {\n        // `JSON.stringify` will throw if the object is cyclical,\n        // in this case the best we can do is report the value as `{...}`.\n        return '{...}';\n    }\n}\n/**\n * Splits up a compound selector into its parts and escapes any quoted content. The quoted content\n * has to be escaped, because it can contain commas which will throw throw us off when trying to\n * split it.\n * @param selector Selector to be split.\n * @returns The escaped string where any quoted content is replaced with a placeholder. E.g.\n * `[foo=\"bar\"]` turns into `[foo=__cdkPlaceholder-0__]`. Use `_restoreSelector` to restore\n * the placeholders.\n */\nfunction _splitAndEscapeSelector(selector) {\n    const placeholders = [];\n    // Note that the regex doesn't account for nested quotes so something like `\"ab'cd'e\"` will be\n    // considered as two blocks. It's a bit of an edge case, but if we find that it's a problem,\n    // we can make it a bit smarter using a loop. Use this for now since it's more readable and\n    // compact. More complete implementation:\n    // https://github.com/angular/angular/blob/bd34bc9e89f18a/packages/compiler/src/shadow_css.ts#L655\n    const result = selector.replace(/([\"'][^[\"']*[\"'])/g, (_, keep) => {\n        const replaceBy = `__cdkPlaceholder-${placeholders.length}__`;\n        placeholders.push(keep);\n        return replaceBy;\n    });\n    return [result.split(',').map(part => part.trim()), placeholders];\n}\n/** Restores a selector whose content was escaped in `_splitAndEscapeSelector`. */\nfunction _restoreSelector(selector, placeholders) {\n    return selector.replace(/__cdkPlaceholder-(\\d+)__/g, (_, index) => placeholders[+index]);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Base harness environment class that can be extended to allow `ComponentHarness`es to be used in\n * different test environments (e.g. testbed, protractor, etc.). This class implements the\n * functionality of both a `HarnessLoader` and `LocatorFactory`. This class is generic on the raw\n * element type, `E`, used by the particular test environment.\n */\nclass HarnessEnvironment {\n    // Implemented as part of the `LocatorFactory` interface.\n    get rootElement() {\n        this._rootElement = this._rootElement || this.createTestElement(this.rawRootElement);\n        return this._rootElement;\n    }\n    set rootElement(element) {\n        this._rootElement = element;\n    }\n    constructor(rawRootElement) {\n        this.rawRootElement = rawRootElement;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    documentRootLocatorFactory() {\n        return this.createEnvironment(this.getDocumentRoot());\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorFor(...queries) {\n        return () => _assertResultFound(this._getAllHarnessesAndTestElements(queries), _getDescriptionForLocatorForQueries(queries));\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorForOptional(...queries) {\n        return async () => (await this._getAllHarnessesAndTestElements(queries))[0] || null;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    locatorForAll(...queries) {\n        return () => this._getAllHarnessesAndTestElements(queries);\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async rootHarnessLoader() {\n        return this;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderFor(selector) {\n        return this.createEnvironment(await _assertResultFound(this.getAllRawElements(selector), [\n            _getDescriptionForHarnessLoaderQuery(selector),\n        ]));\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderForOptional(selector) {\n        const elements = await this.getAllRawElements(selector);\n        return elements[0] ? this.createEnvironment(elements[0]) : null;\n    }\n    // Implemented as part of the `LocatorFactory` interface.\n    async harnessLoaderForAll(selector) {\n        const elements = await this.getAllRawElements(selector);\n        return elements.map(element => this.createEnvironment(element));\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    getHarness(query) {\n        return this.locatorFor(query)();\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    getHarnessOrNull(query) {\n        return this.locatorForOptional(query)();\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    getAllHarnesses(query) {\n        return this.locatorForAll(query)();\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    async hasHarness(query) {\n        return (await this.locatorForOptional(query)()) !== null;\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    async getChildLoader(selector) {\n        return this.createEnvironment(await _assertResultFound(this.getAllRawElements(selector), [\n            _getDescriptionForHarnessLoaderQuery(selector),\n        ]));\n    }\n    // Implemented as part of the `HarnessLoader` interface.\n    async getAllChildLoaders(selector) {\n        return (await this.getAllRawElements(selector)).map(e => this.createEnvironment(e));\n    }\n    /** Creates a `ComponentHarness` for the given harness type with the given raw host element. */\n    createComponentHarness(harnessType, element) {\n        return new harnessType(this.createEnvironment(element));\n    }\n    /**\n     * Matches the given raw elements with the given list of element and harness queries to produce a\n     * list of matched harnesses and test elements.\n     */\n    async _getAllHarnessesAndTestElements(queries) {\n        if (!queries.length) {\n            throw Error('CDK Component harness query must contain at least one element.');\n        }\n        const { allQueries, harnessQueries, elementQueries, harnessTypes } = _parseQueries(queries);\n        // Combine all of the queries into one large comma-delimited selector and use it to get all raw\n        // elements matching any of the individual queries.\n        const rawElements = await this.getAllRawElements([...elementQueries, ...harnessQueries.map(predicate => predicate.getSelector())].join(','));\n        // If every query is searching for the same harness subclass, we know every result corresponds\n        // to an instance of that subclass. Likewise, if every query is for a `TestElement`, we know\n        // every result corresponds to a `TestElement`. Otherwise we need to verify which result was\n        // found by which selector so it can be matched to the appropriate instance.\n        const skipSelectorCheck = (elementQueries.length === 0 && harnessTypes.size === 1) || harnessQueries.length === 0;\n        const perElementMatches = await parallel(() => rawElements.map(async (rawElement) => {\n            const testElement = this.createTestElement(rawElement);\n            const allResultsForElement = await parallel(\n            // For each query, get `null` if it doesn't match, or a `TestElement` or\n            // `ComponentHarness` as appropriate if it does match. This gives us everything that\n            // matches the current raw element, but it may contain duplicate entries (e.g.\n            // multiple `TestElement` or multiple `ComponentHarness` of the same type).\n            () => allQueries.map(query => this._getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck)));\n            return _removeDuplicateQueryResults(allResultsForElement);\n        }));\n        return [].concat(...perElementMatches);\n    }\n    /**\n     * Check whether the given query matches the given element, if it does return the matched\n     * `TestElement` or `ComponentHarness`, if it does not, return null. In cases where the caller\n     * knows for sure that the query matches the element's selector, `skipSelectorCheck` can be used\n     * to skip verification and optimize performance.\n     */\n    async _getQueryResultForElement(query, rawElement, testElement, skipSelectorCheck = false) {\n        if (typeof query === 'string') {\n            return skipSelectorCheck || (await testElement.matchesSelector(query)) ? testElement : null;\n        }\n        if (skipSelectorCheck || (await testElement.matchesSelector(query.getSelector()))) {\n            const harness = this.createComponentHarness(query.harnessType, rawElement);\n            return (await query.evaluate(harness)) ? harness : null;\n        }\n        return null;\n    }\n}\n/**\n * Parses a list of queries in the format accepted by the `locatorFor*` methods into an easier to\n * work with format.\n */\nfunction _parseQueries(queries) {\n    const allQueries = [];\n    const harnessQueries = [];\n    const elementQueries = [];\n    const harnessTypes = new Set();\n    for (const query of queries) {\n        if (typeof query === 'string') {\n            allQueries.push(query);\n            elementQueries.push(query);\n        }\n        else {\n            const predicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n            allQueries.push(predicate);\n            harnessQueries.push(predicate);\n            harnessTypes.add(predicate.harnessType);\n        }\n    }\n    return { allQueries, harnessQueries, elementQueries, harnessTypes };\n}\n/**\n * Removes duplicate query results for a particular element. (e.g. multiple `TestElement`\n * instances or multiple instances of the same `ComponentHarness` class.\n */\nasync function _removeDuplicateQueryResults(results) {\n    let testElementMatched = false;\n    let matchedHarnessTypes = new Set();\n    const dedupedMatches = [];\n    for (const result of results) {\n        if (!result) {\n            continue;\n        }\n        if (result instanceof ComponentHarness) {\n            if (!matchedHarnessTypes.has(result.constructor)) {\n                matchedHarnessTypes.add(result.constructor);\n                dedupedMatches.push(result);\n            }\n        }\n        else if (!testElementMatched) {\n            testElementMatched = true;\n            dedupedMatches.push(result);\n        }\n    }\n    return dedupedMatches;\n}\n/** Verifies that there is at least one result in an array. */\nasync function _assertResultFound(results, queryDescriptions) {\n    const result = (await results)[0];\n    if (result == undefined) {\n        throw Error(`Failed to find element matching one of the following queries:\\n` +\n            queryDescriptions.map(desc => `(${desc})`).join(',\\n'));\n    }\n    return result;\n}\n/** Gets a list of description strings from a list of queries. */\nfunction _getDescriptionForLocatorForQueries(queries) {\n    return queries.map(query => typeof query === 'string'\n        ? _getDescriptionForTestElementQuery(query)\n        : _getDescriptionForComponentHarnessQuery(query));\n}\n/** Gets a description string for a `ComponentHarness` query. */\nfunction _getDescriptionForComponentHarnessQuery(query) {\n    const harnessPredicate = query instanceof HarnessPredicate ? query : new HarnessPredicate(query, {});\n    const { name, hostSelector } = harnessPredicate.harnessType;\n    const description = `${name} with host element matching selector: \"${hostSelector}\"`;\n    const constraints = harnessPredicate.getDescription();\n    return (description +\n        (constraints ? ` satisfying the constraints: ${harnessPredicate.getDescription()}` : ''));\n}\n/** Gets a description string for a `TestElement` query. */\nfunction _getDescriptionForTestElementQuery(selector) {\n    return `TestElement for element matching selector: \"${selector}\"`;\n}\n/** Gets a description string for a `HarnessLoader` query. */\nfunction _getDescriptionForHarnessLoaderQuery(selector) {\n    return `HarnessLoader for element matching selector: \"${selector}\"`;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** An enum of non-text keys that can be used with the `sendKeys` method. */\n// NOTE: This is a separate enum from `@angular/cdk/keycodes` because we don't necessarily want to\n// support every possible keyCode. We also can't rely on Protractor's `Key` because we don't want a\n// dependency on any particular testing framework here. Instead we'll just maintain this supported\n// list of keys and let individual concrete `HarnessEnvironment` classes map them to whatever key\n// representation is used in its respective testing framework.\n// tslint:disable-next-line:prefer-const-enum Seems like this causes some issues with System.js\nvar TestKey;\n(function (TestKey) {\n    TestKey[TestKey[\"BACKSPACE\"] = 0] = \"BACKSPACE\";\n    TestKey[TestKey[\"TAB\"] = 1] = \"TAB\";\n    TestKey[TestKey[\"ENTER\"] = 2] = \"ENTER\";\n    TestKey[TestKey[\"SHIFT\"] = 3] = \"SHIFT\";\n    TestKey[TestKey[\"CONTROL\"] = 4] = \"CONTROL\";\n    TestKey[TestKey[\"ALT\"] = 5] = \"ALT\";\n    TestKey[TestKey[\"ESCAPE\"] = 6] = \"ESCAPE\";\n    TestKey[TestKey[\"PAGE_UP\"] = 7] = \"PAGE_UP\";\n    TestKey[TestKey[\"PAGE_DOWN\"] = 8] = \"PAGE_DOWN\";\n    TestKey[TestKey[\"END\"] = 9] = \"END\";\n    TestKey[TestKey[\"HOME\"] = 10] = \"HOME\";\n    TestKey[TestKey[\"LEFT_ARROW\"] = 11] = \"LEFT_ARROW\";\n    TestKey[TestKey[\"UP_ARROW\"] = 12] = \"UP_ARROW\";\n    TestKey[TestKey[\"RIGHT_ARROW\"] = 13] = \"RIGHT_ARROW\";\n    TestKey[TestKey[\"DOWN_ARROW\"] = 14] = \"DOWN_ARROW\";\n    TestKey[TestKey[\"INSERT\"] = 15] = \"INSERT\";\n    TestKey[TestKey[\"DELETE\"] = 16] = \"DELETE\";\n    TestKey[TestKey[\"F1\"] = 17] = \"F1\";\n    TestKey[TestKey[\"F2\"] = 18] = \"F2\";\n    TestKey[TestKey[\"F3\"] = 19] = \"F3\";\n    TestKey[TestKey[\"F4\"] = 20] = \"F4\";\n    TestKey[TestKey[\"F5\"] = 21] = \"F5\";\n    TestKey[TestKey[\"F6\"] = 22] = \"F6\";\n    TestKey[TestKey[\"F7\"] = 23] = \"F7\";\n    TestKey[TestKey[\"F8\"] = 24] = \"F8\";\n    TestKey[TestKey[\"F9\"] = 25] = \"F9\";\n    TestKey[TestKey[\"F10\"] = 26] = \"F10\";\n    TestKey[TestKey[\"F11\"] = 27] = \"F11\";\n    TestKey[TestKey[\"F12\"] = 28] = \"F12\";\n    TestKey[TestKey[\"META\"] = 29] = \"META\";\n})(TestKey || (TestKey = {}));\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an error which reports that no keys have been specified.\n * @docs-private\n */\nfunction getNoKeysSpecifiedError() {\n    return Error('No keys have been specified.');\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Gets text of element excluding certain selectors within the element.\n * @param element Element to get text from,\n * @param excludeSelector Selector identifying which elements to exclude,\n */\nfunction _getTextWithExcludedElements(element, excludeSelector) {\n    const clone = element.cloneNode(true);\n    const exclusions = clone.querySelectorAll(excludeSelector);\n    for (let i = 0; i < exclusions.length; i++) {\n        exclusions[i].remove();\n    }\n    return (clone.textContent || '').trim();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport { ComponentHarness, ContentContainerComponentHarness, HarnessEnvironment, HarnessPredicate, TestKey, _getTextWithExcludedElements, getNoKeysSpecifiedError, handleAutoChangeDetectionStatus, manualChangeDetection, parallel, stopHandlingAutoChangeDetectionStatus };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}